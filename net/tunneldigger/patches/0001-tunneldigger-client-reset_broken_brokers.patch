diff --git a/client/l2tp_client.c b/client/l2tp_client.c
index 16fdf3c..69ce54c 100644
--- a/client/l2tp_client.c
+++ b/client/l2tp_client.c
@@ -1431,10 +1431,6 @@ int main(int argc, char **argv)

     // Reset availability information and standby setting.
     for (i = 0; i < broker_cnt; i++) {
-      // Re-enable all brokers if they are all broken
-      if (working_brokers == 0) {
-        brokers[i].broken = 0;
-      }
       if (brokers[i].broken) {
         // Inhibit hostname resolution and connect process.
         syslog(LOG_INFO, "Not trying %s:%s again as it broke last time we tried.",
@@ -1442,11 +1438,6 @@ int main(int argc, char **argv)
         brokers[i].ctx->state = STATE_FAILED;
       }
     }
-    // Adapt working_brokers, needs updating if we re-enabled brokers
-    if (working_brokers == 0) {
-      syslog(LOG_INFO, "All brokers sent us an error, trying them all again.");
-      working_brokers = broker_cnt;
-    }

     // Perform broker processing for 10 seconds or until all brokers are ready
     // (whichever is shorter); since all contexts are in standby mode, all
@@ -1474,8 +1465,14 @@ int main(int argc, char **argv)

     i = select_broker(brokers, broker_cnt, ready_cnt);
     if (i == -1) {
-      syslog(LOG_ERR, "No suitable brokers found. Retrying in 5 seconds");
+      syslog(LOG_ERR, "No suitable brokers found. Retrying in 5 seconds.");
       sleep(5);
+      // Un-break all brokers.  There is no point in avoiding bad brokers if that means
+      // we have no candidates left.
+      syslog(LOG_ERR, "Resetting status of brokers and starting from scratch.");
+      for (i = 0; i < broker_cnt; i++) {
+        brokers[i].broken = 0;
+      }
       continue;
     }


